在 C++ 中，`const` 关键字的位置（相对于 `*` 或 `&` 的左右位置）决定了其修饰的对象类型。以下是具体的区别和示例：

---

### **一、指针中的 `const` 位置**
#### **1. `const` 在 `*` 左侧**
```cpp
const int* ptr;  // 或等价写法：int const* ptr;
```
- **含义**：指针指向的值是常量（不可修改），但指针本身可以指向其他地址。
- **特性**：
  - **底层 `const`**：约束的是指针指向的数据的常量性。
  - 不能通过指针修改指向的值。
  - 指针可以重新指向其他地址。
- **示例**：
  ```cpp
  const int a = 10;
  const int* ptr = &a;  // 合法
  // *ptr = 20;        // 错误：无法修改常量值
  int b = 30;
  ptr = &b;            // 合法：指针可以重新指向
  ```

#### **2. `const` 在 `*` 右侧**
```cpp
int* const ptr;
```
- **含义**：指针本身是常量（不可修改指向的地址），但指向的值可以修改。
- **特性**：
  - **顶层 `const`**：约束的是指针本身的常量性。
  - 可以通过指针修改指向的值。
  - 指针不能重新指向其他地址。
- **示例**：
  ```cpp
  int a = 10;
  int* const ptr = &a;  // 合法
  *ptr = 20;            // 合法：可以修改值
  // ptr = &b;         // 错误：指针是常量，不能重新指向
  ```

#### **3. `const` 在 `*` 两侧**
```cpp
const int* const ptr;
```
- **含义**：指针本身是常量，且指向的值也是常量。
- **特性**：
  - 既不能修改指针的指向，也不能通过指针修改指向的值。
- **示例**：
  ```cpp
  const int a = 10;
  const int* const ptr = &a;
  // *ptr = 20;        // 错误：值不可修改
  // ptr = &b;         // 错误：指针不可修改
  ```

---

### **二、引用中的 `const` 位置**
引用本身不能重新绑定（天然具有类似 `* const` 的特性），因此 `const` 的位置只影响引用的值的常量性。

#### **1. `const` 在 `&` 左侧**
```cpp
const int& ref = a;  // 或等价写法：int const& ref = a;
```
- **含义**：引用绑定到一个常量值（不可通过引用修改原值）。
- **特性**：
  - 引用的值不可修改。
  - 原值本身可以是变量或常量。
- **示例**：
  ```cpp
  int a = 10;
  const int& ref = a;
  // ref = 20;        // 错误：不能通过引用修改值
  a = 20;             // 合法：原值本身是变量
  ```

#### **2. `const` 在 `&` 右侧（无意义）**
```cpp
int& const ref = a;  // 等价于 int& ref = a;
```
- **含义**：引用本身是常量（但引用天然不可重新绑定，因此 `const` 是冗余的）。
- **特性**：
  - C++ 中禁止显式声明 `const` 引用（直接报错）。
  - 实际代码中应省略右侧的 `const`。

---

### **三、对比表格**
| **语法**          | 修饰对象         | 能否修改值？ | 能否重新指向？ | 典型场景              |
|--------------------|------------------|--------------|----------------|-----------------------|
| `const int* ptr`   | 指向的值         | ❌            | ✔️             | 传递只读数据          |
| `int* const ptr`   | 指针本身         | ✔️            | ❌             | 固定指针地址          |
| `const int& ref`   | 引用的值         | ❌            | ❌（天然不可变）| 传递只读引用          |
| `int& ref`         | 引用的值         | ✔️            | ❌（天然不可变）| 传递可修改的引用      |

---

### **四、关键规则总结**
1. **指针的 `const`**：
   - **左侧 `const`**：保护指向的值（底层 `const`）。
   - **右侧 `const`**：保护指针本身（顶层 `const`）。
2. **引用的 `const`**：
   - 引用天然不可重新绑定（类似 `* const`），因此 `const` 只约束值的可修改性。
3. **混合使用**：
   ```cpp
   const int* const ptr;  // 值和指针均不可变
   const int& const ref;  // 语法错误（引用不能重复 `const`）
   ```

---

### **五、实际应用示例**
#### **场景 1：函数参数传递**
```cpp
void ReadData(const int* data);  // 安全传递只读数据
void ModifyData(int* const data); // 固定指针地址，允许修改值（少见）
```

#### **场景 2：返回常量引用**
```cpp
const std::string& GetName() {
  static std::string name = "Alice";
  return name;  // 返回常量引用，防止外部修改
}
```

#### **场景 3：常量指针遍历数组**
```cpp
const int arr[] = {1, 2, 3};
for (const int* p = arr; p != arr + 3; ++p) {
  std::cout << *p << " ";  // 合法：读取值
  // *p = 0;              // 错误：值不可修改
}
```

---

### **六、常见错误**
1. **试图修改底层 `const` 指针的值**：
   ```cpp
   const int a = 10;
   const int* ptr = &a;
   *ptr = 20;  // 错误：assignment of read-only location
   ```

2. **误用顶层 `const` 指针**：
   ```cpp
   int a = 10, b = 20;
   int* const ptr = &a;
   ptr = &b;  // 错误：assignment of read-only variable 'ptr'
   ```

3. **冗余的引用 `const`**：
   ```cpp
   int a = 10;
   int& const ref = a;  // 错误：'const' qualifiers cannot be applied to 'int&'
   ```

---

### **总结**
理解 `const` 在 `*` 和 `&` 左右位置的区别，本质是明确 **`const` 修饰的是指针/引用本身还是其指向/引用的值**。通过合理使用 `const`，可以增强代码的安全性和可读性。