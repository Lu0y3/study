

ä»¥ä¸‹æ˜¯æ ¹æ®å›¾ç‰‡æè¿°å®ç°çš„ **åŒçº¿ç¨‹äº¤æ›¿æ‰§è¡Œé€’å¢æ“ä½œ** çš„å®Œæ•´æ¡ˆä¾‹ï¼Œä½¿ç”¨äº’æ–¥é‡å’Œæ¡ä»¶å˜é‡å®ç°ä¸¥æ ¼äº¤æ›¿æ§åˆ¶ï¼š

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class AlternatingIncrementer {
private:
    std::mutex mtx;
    std::condition_variable cv;
    int myvalue = 0;
    bool turn = false;  // falseè¡¨ç¤ºçº¿ç¨‹1çš„å›åˆï¼Œtrueè¡¨ç¤ºçº¿ç¨‹2çš„å›åˆ
    const int max_count = 10;

public:
    void run() {
        std::thread t1(&AlternatingIncrementer::thread1_work, this);
        std::thread t2(&AlternatingIncrementer::thread2_work, this);
        
        t1.join();
        t2.join();
        
        std::cout << "Final value: " << myvalue << std::endl;
    }

private:
    void thread1_work() {
        for (int i = 0; i < max_count; ) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [this]{ return !turn; });  // ç­‰å¾…è½®åˆ°çº¿ç¨‹1
            
            std::cout << "Thread 1: " << ++myvalue << std::endl;
            turn = true;  // åˆ‡æ¢ä¸ºçº¿ç¨‹2çš„å›åˆ
            ++i;
            
            cv.notify_one();  // é€šçŸ¥çº¿ç¨‹2
        }
    }

    void thread2_work() {
        for (int i = 0; i < max_count; ) {
            std::unique_lock<std::mutex> lock(mtx);
            cv.wait(lock, [this]{ return turn; });  // ç­‰å¾…è½®åˆ°çº¿ç¨‹2
            
            std::cout << "Thread 2: " << ++myvalue << std::endl;
            turn = false;  // åˆ‡æ¢ä¸ºçº¿ç¨‹1çš„å›åˆ
            ++i;
            
            cv.notify_one();  // é€šçŸ¥çº¿ç¨‹1
        }
    }
};

int main() {
    AlternatingIncrementer ai;
    ai.run();
    return 0;
}
```

---

### ä»£ç è§£æ

#### 1. åŒæ­¥æœºåˆ¶è®¾è®¡
| ç»„ä»¶                | ä½œç”¨                          |
|---------------------|-------------------------------|
| `std::mutex`        | ä¿æŠ¤å…±äº«å˜é‡ `myvalue` å’Œ `turn` |
| `std::condition_variable` | æ§åˆ¶çº¿ç¨‹æ‰§è¡Œé¡ºåº            |
| `bool turn`         | å›åˆæ ‡å¿— (true/false åˆ‡æ¢)     |

#### 2. çº¿ç¨‹å·¥ä½œé€»è¾‘
```cpp
// çº¿ç¨‹1ä¼ªä»£ç 
while(æœªå®Œæˆ):
    ç­‰å¾…ç›´åˆ° turn == false
    é€’å¢myvalue
    turn = true
    é€šçŸ¥çº¿ç¨‹2

// çº¿ç¨‹2ä¼ªä»£ç 
while(æœªå®Œæˆ):
    ç­‰å¾…ç›´åˆ° turn == true
    é€’å¢myvalue
    turn = false
    é€šçŸ¥çº¿ç¨‹1
```

#### 3. å…³é”®å‡½æ•°è¯´æ˜
â€¢ **cv.wait(lock, predicate)**  
  é˜»å¡çº¿ç¨‹ç›´åˆ°ï¼š  
  1) æ”¶åˆ°notifyä¿¡å·  
  2) predicateæ¡ä»¶ä¸ºçœŸ (é˜²æ­¢è™šå‡å”¤é†’)

â€¢ **cv.notify_one()**  
  ç²¾å‡†å”¤é†’å¦ä¸€ä¸ªç­‰å¾…çº¿ç¨‹

---

### æ‰§è¡Œç»“æœç¤ºä¾‹
```
Thread 1: 1
Thread 2: 2
Thread 1: 3
Thread 2: 4
...
Thread 2: 20
Final value: 20
```

---

### åŒæ­¥æµç¨‹å›¾è§£
```mermaid
sequenceDiagram
    participant T1 as Thread1
    participant T2 as Thread2
    T1->>T1: ç­‰å¾…turn=false
    T1->>T1: é€’å¢myvalue
    T1->>T2: notify_one()
    T2->>T2: ç­‰å¾…turn=true
    T2->>T2: é€’å¢myvalue
    T2->>T1: notify_one()
    loop 10æ¬¡äº¤æ›¿
        T1->>T2: å”¤é†’é€šçŸ¥
        T2->>T1: å”¤é†’é€šçŸ¥
    end
```

---

### ç¼–è¯‘æ‰§è¡Œ
```bash
# ç¼–è¯‘å‘½ä»¤ (éœ€è¦C++11æ”¯æŒ)
g++ -std=c++11 -pthread alternating_threads.cpp -o alt_threads

# è¿è¡Œç»“æœ
./alt_threads
```

---

### è®¾è®¡äº®ç‚¹
1. **å°è£…æ€§**ï¼šé€šè¿‡ç±»å°è£…å…±äº«èµ„æºå’ŒåŒæ­¥é€»è¾‘
2. **ç²¾å‡†æ§åˆ¶**ï¼šä½¿ç”¨å•ä¸ªæ¡ä»¶å˜é‡+å¸ƒå°”æ ‡å¿—å®ç°ä¸¥æ ¼äº¤æ›¿
3. **æ‰©å±•æ€§**ï¼šé€šè¿‡ä¿®æ”¹ `max_count` å¯æ§åˆ¶æ€»é€’å¢æ¬¡æ•°
4. **å¼‚å¸¸å®‰å…¨**ï¼šunique_lockè‡ªåŠ¨ç®¡ç†é”ç”Ÿå‘½å‘¨æœŸ

è¯¥æ¡ˆä¾‹å®Œæ•´å®ç°äº†å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„å®‰å…¨äº¤æ›¿æ“ä½œï¼Œå¯ä½œä¸ºçº¿ç¨‹åŒæ­¥çš„ç»å…¸æ•™å­¦æ¡ˆä¾‹ã€‚éœ€è¦è¿›ä¸€æ­¥è§£é‡Šç‰¹å®šå®ç°ç»†èŠ‚å—ï¼Ÿ ğŸ˜Š